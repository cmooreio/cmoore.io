import{_ as t,c as r,o as a,ag as o}from"./chunks/framework.CI6Ra_OS.js";const u=JSON.parse('{"title":"Infrastructure","description":"","frontmatter":{"prev":{"text":"Software Overview","link":"/components/"},"next":{"text":"Observability","link":"/components/observability"}},"headers":[],"relativePath":"components/infrastructure.md","filePath":"components/infrastructure.md"}'),n={name:"components/infrastructure.md"};function i(s,e,l,c,d,p){return a(),r("div",null,[...e[0]||(e[0]=[o('<h1 id="infrastructure" tabindex="-1">Infrastructure <a class="header-anchor" href="#infrastructure" aria-label="Permalink to &quot;Infrastructure&quot;">​</a></h1><p>The cluster&#39;s foundation layer handles orchestration, storage, networking, and secrets management.</p><h2 id="k3s" tabindex="-1">K3s <a class="header-anchor" href="#k3s" aria-label="Permalink to &quot;K3s&quot;">​</a></h2><p><a href="https://k3s.io/" target="_blank" rel="noreferrer">K3s</a> is a lightweight, certified Kubernetes distribution built for edge and IoT environments. It packages the entire control plane into a single binary under 100MB.</p><p>The cluster runs <strong>3 control plane nodes</strong> for high availability (etcd quorum) and <strong>7 worker nodes</strong> (5 general-purpose + 2 AI inference).</p><div class="info custom-block"><p class="custom-block-title">Cluster Topology</p><ul><li><strong>Control plane</strong>: rpi1, rpi2, rpi3 (etcd + API server)</li><li><strong>General workers</strong>: rpi4 - rpi8</li><li><strong>AI inference</strong>: aimax (ROCm), thor (CUDA)</li></ul></div><h2 id="longhorn" tabindex="-1">Longhorn <a class="header-anchor" href="#longhorn" aria-label="Permalink to &quot;Longhorn&quot;">​</a></h2><p><a href="https://longhorn.io/" target="_blank" rel="noreferrer">Longhorn</a> provides cloud-native distributed block storage with automatic replication across nodes.</p><table tabindex="0"><thead><tr><th>Feature</th><th>Configuration</th></tr></thead><tbody><tr><td><strong>Replication</strong></td><td>3x for critical data</td></tr><tr><td><strong>Storage Backend</strong></td><td>NVMe SSD on each node</td></tr><tr><td><strong>Snapshots</strong></td><td>Automatic with S3 backup</td></tr><tr><td><strong>Volume Mode</strong></td><td>RWO (ReadWriteOnce)</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">Deployment Pattern</p><p>Applications with RWO PVCs use <code>Recreate</code> strategy instead of <code>RollingUpdate</code> to prevent Multi-Attach errors when pods reschedule to different nodes.</p></div><h2 id="traefik" tabindex="-1">Traefik <a class="header-anchor" href="#traefik" aria-label="Permalink to &quot;Traefik&quot;">​</a></h2><p><a href="https://traefik.io/" target="_blank" rel="noreferrer">Traefik</a> serves as the ingress controller and reverse proxy, handling TLS termination and routing for all web-facing services.</p><ul><li>Automatic HTTPS via cert-manager and Let&#39;s Encrypt</li><li>Middleware for rate limiting, headers, and redirects</li><li>LoadBalancer IP: <code>192.168.64.1</code> via kube-vip</li></ul><h2 id="argocd" tabindex="-1">ArgoCD <a class="header-anchor" href="#argocd" aria-label="Permalink to &quot;ArgoCD&quot;">​</a></h2><p><a href="https://argo-cd.readthedocs.io/" target="_blank" rel="noreferrer">ArgoCD</a> manages all application deployments using the <strong>App-of-Apps</strong> pattern. A single root Application watches the <code>kubernetes/argocd/applications/</code> directory and automatically creates child Applications for each service.</p><table tabindex="0"><thead><tr><th>Setting</th><th>Value</th></tr></thead><tbody><tr><td><strong>Sync interval</strong></td><td>3 minutes</td></tr><tr><td><strong>Self-heal</strong></td><td>Enabled</td></tr><tr><td><strong>LoadBalancer IP</strong></td><td><code>192.168.64.120</code></td></tr></tbody></table><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Never use <code>kubectl edit</code> or <code>kubectl apply</code> directly. ArgoCD&#39;s self-heal will revert your changes within minutes. Always commit to Git and let ArgoCD sync.</p></div><h2 id="cert-manager" tabindex="-1">cert-manager <a class="header-anchor" href="#cert-manager" aria-label="Permalink to &quot;cert-manager&quot;">​</a></h2><p><a href="https://cert-manager.io/" target="_blank" rel="noreferrer">cert-manager</a> automates TLS certificate provisioning and renewal using Let&#39;s Encrypt. Certificates are issued via Cloudflare DNS-01 challenges and stored as Kubernetes Secrets.</p><h2 id="sealed-secrets" tabindex="-1">Sealed Secrets <a class="header-anchor" href="#sealed-secrets" aria-label="Permalink to &quot;Sealed Secrets&quot;">​</a></h2><p><a href="https://sealed-secrets.netlify.app/" target="_blank" rel="noreferrer">Sealed Secrets</a> enables storing encrypted secrets in Git. The controller running in-cluster decrypts them into regular Kubernetes Secrets at deploy time. Only the cluster&#39;s private key can decrypt sealed secrets.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Never commit plaintext secrets to the repository. Always use <code>kubeseal</code> to encrypt them first.</p></div><h2 id="network-policies" tabindex="-1">Network Policies <a class="header-anchor" href="#network-policies" aria-label="Permalink to &quot;Network Policies&quot;">​</a></h2><p>Network policies follow an <strong>allow-first, deny-all</strong> approach:</p><ol><li>Create <code>NetworkPolicy</code> rules that explicitly allow required traffic</li><li>Apply a default-deny policy last to block everything else</li></ol><p>This ensures services can only communicate with their declared dependencies.</p>',26)])])}const g=t(n,[["render",i]]);export{u as __pageData,g as default};
